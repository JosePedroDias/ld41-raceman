{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/poly-decomp/src/index.js","webpack:///./src/exposePolyDecomp.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","lineInt","l1","l2","precision","a1","b1","c1","a2","b2","c2","det","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","t","triangleArea","a","b","isLeft","isLeftOn","isRight","isRightOn","decomp","polygon","edges","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","length","polygonIsReflex","j","polygonCanSee","polygonCopy","k","push","polygonAt","polygonSlice","cutEdges","Array","polys","cutEdge","poly","result","splice","indexOf","quickDecomp","polygonQuickDecomp","reflexVertices","steinerPoints","delta","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","v","console","warn","getIntersectionPoint","sqdist","polygonAppend","isSimple","path","removeCollinearPoints","num","collinear","makeCCW","br","tmp","N","pop","polygonReverse","tmpPoint1","tmpPoint2","thresholdAngle","ab","bc","dot","magA","Math","sqrt","magB","acos","from","to","tmpLine1","tmpLine2","dist","targetPoly","polygonClear","abs","window","poly_decomp__WEBPACK_IMPORTED_MODULE_0___default"],"mappings":"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","file":"exposePolyDecomp.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 92);\n","module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) < precision;\n}\n","// @ts-ignore\nimport decomp from 'poly-decomp';\n\n// @ts-ignore\nwindow.decomp = decomp;\n"],"sourceRoot":""}